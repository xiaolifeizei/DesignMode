# 设计模式 Design Pattern

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

设计模式分为三种类型，共23种：

- **创建型模式**：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
- **结构型模式**：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- **行为型模式**：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。

## 适配器模式（Adapter）

适配器模式

### 说明

可以让一个类在两个独立的维度变化，这两个维度都可以进行扩展，适配器模式只在一个维度实现继承，所以不会因为多维度、多层次继承导致系统类的个数急剧增加，这就让构件的抽象化角色和具体化角色之间增加了更多的灵活性。

### 角色

- Abstraction：抽象类。

- RefinedAbstraction：扩充抽象类。

- Implementor：实现类接口。

- ConcreteImplementor：具体实现类 。

### 说明

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

### 角色

- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

- 需要适配的类（Adaptee）：需要适配的类或适配者类。

- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

## 桥接模式（Bridge）

桥接模式

## 建造者模式（Builder）

建造者模式

### 说明

**以下情况建议使用建造者模式**

- 某个对象有复杂的内部结构，通常包含多个成员属性，而且属性是可选的。

- 相同的方法，不同的执行顺序，产生不同的对象或不同的运行结果。

- 当创建一个对象需要很多步骤时，适合使用建造者模式。

## 责任链模式（Chain Of Responsibility）

责任链模式

## 命令模式（Command）

命令模式又叫动作（Action）模式或事务（Transaction）模式。

### 说明

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

- 命令模式的本质：命令发出者不知道最终的执行者是谁，实现命令发出者与执行者之间的解耦，让请求与执行进行分离
- 命令模式的目的：将一个请求封装到一个对象中，实现用不同的请求对客户端参数化

### 角色

- 抽象命令（Command）角色：封装一个普适方法，定义命令的接口，声明执行的方法

- 具体命令（Concrete Command）角色：具体的命令，实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作

- 接受者（Receiver）角色：真正执行命令的对象，只要它能够实现命令要求实现的相应功能

  Receiver可以是任意类型，包括：

  ①固定的具体类

  ②抽象类型，真正执行命令的对象是其子类

  ③临时的接受者，以匿名类或lambda表达式的形式传入

- 请求者（Invoker）角色：调用命令对象执行请求，通常会持有命令对象，也可以持有很多的命令对象，相当于客户端使用命令对象的入口

### 总结

Invoker不知道应该依赖谁，因此依赖封装普适方法execute()的命令；execute()作为适配目标，Command模式是适配器模式的特例。

可以用过程语言中的回调（callback）函数表达这种参数化机制，命令模式是回调机制的一个面向对象的替代品。

使用场景：

1) 界面的一个按钮都是一条命令、模拟CMD（DOS命令）命令、 订单的撤销/恢复、触发-反馈机制
2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象（Concrete Command）和请求的调用者（Invoker）可以有不同的生命期，换言之，请求调用者（Invoker）可能已经不在了，而命令对象（Concrete Command）本身仍然是活动的，可以通过该命令对象去调用请求接收者（Receiver），而无须关心请求调用者（Invoker）的存在性，可以通过请求日志文件等机制来具体实现
3) 系统需要将请求调用者（Invoker）和请求接收者（Receiver）解耦，使得调用者（Invoker）和接收者（Receiver）不直接交互。请求调用者（Invoker）无须知道接收者（Receiver）的存在，也无须知道接收者（Receiver）是谁，接收者（Receiver）也无须关心何时被调用
4) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作
5) 系统需要将一组操作组合在一起形成宏命令。认为是命令的地方都可以使用命令模式，比如： GUI 中每一个按钮都是一条命令。

## 组合模式（Composite）

组合模式

### 说明

组合(Composite)模式是一种对象的行为模式。将对象组合成`树形结构`以表示`部分--整体`的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。组合模式又可以称为`整体—部分(Part-Whole)模式`，它是一种对象结构型模式。

- 组合模式的本质：统一叶子对象和组合对象。

- 组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

### 角色

- 抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，
  可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里， 
  构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
- 树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
- 树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，
  如add()、remove()以及getChild()。

### 实现方式

#### 1、安全性组合模式

从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。

#### 2、透明性组合模式

从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。

### 总结

对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用合成模式的时候，建议多采用透明性的实现方式。

## 外观模式（Facade）

外观模式，又叫门面模式。

### 说明

 一个复杂的过程需要高级的接口以及具体实现的实现类，对于调用者来说并不关心实现的细节，只关心结果调用和结果输出。可以拆分子系统，或者用单独的类进行构造门面模式。通过定义一个一致的接口,用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

### 角色

- 外观(Facade)角色：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求

  从而将调用端的请求代理给适当子系统对象。

- 客户端(Client)角色：外观接口的调用者。

- 子系统(SubSystem)角色：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

### 总结

外观模式并不符合`开闭原则`，需要修改原来的接口代码进行改造。

外观模式的注意事项和细节：

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性；

2. 外观模式对客户端与子系统的耦合关系进行解耦，让子系统内部的模块更易维护和扩展；

3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次；

4. 当系统`需要进行分层设计`时，可以考虑使用Facade模式；

5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，

   此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 

   让新系统与Facade类交互，提高复用性；

6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

## 工厂模式（Factory）

工厂模式

## 享元模式（Flyweight）

享元模式

### 说明

享元模式（Flyweight）又称为轻量级模式，是一种对象结构型模式。很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。

享元模式是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。

享元模式 把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。

- 享元模式的本质：缓存共享对象，降低内存消耗

- 享元模式的目的：当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多处需要使用的地方，避免大量同一对象的多次创建，消耗大量内存空间。

享元模式其实就是 工厂模式 的一个改进机制，享元模式 同样要求创建一个或一组对象，并且就是通过工厂方法生成对象的，只不过 享元模式 中为工厂方法增加了缓存这一功能。

### 角色

- 抽象享元（Flyweight）角色：享元对象的抽象，定义了对象的外部状态和内部状态的接口或实现
- 享元（Concrete Flyweight）角色：具体的享元角色，抽象享元的实现类，实现了抽象角色定义的相关业务
- 享元工厂（Flyweight Factory）角色：享元工厂类，内部提供一个池容器，储存Concrete Flyweight，提供从池中存取数据的操作

### 总结

享元模式通常与工厂模式一起使用，可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低内存占用，增强程序的性能。享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享；但是这种模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化，而且为了使对象可以共享，需要将享元对象的外部状态必须具备固化特性，即不应该随内部状态改变而改变，否则会导致系统的逻辑混乱。

使用场景

- 系统中存在大量的相同或相似对象；
- 对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份；
- 需要缓冲池的场景；
- 在Java中，数据库连接池，线程池等即是享元模式的应用。

## 解释器模式（Interpreter）

解释器模式

### 说明

解释器模式属于行为型模式，提供了一种评估计算语言语法或表达式的方法。给定一个**语言**，定义它的**文法**的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

​	语言：使用规定格式和文法的一类字符组合

​	文法，简单说就是“语法规则”

例如Java定义变量：

​	文法：[public|protected|private] + [static] + [final] + 变量类型 + 变量名 + [= 初始值] + 分号

​	语言：private static final String name = "hello";

模式的本质与设计意图：

- 模式本质：分离实现，解释执行

- 设计意图：为语言中不同的文法表示，分别定义一个与该文法表示相对应的解释器，然后通过这个解释器来对该文法表示进行解释 

### 角色

- 抽象表达式（Abstract Expression）角色：

  约定解释器的解释操作，主要是一个interpret()方法

- 终结符表达式（Terminal Expression）角色：

  抽象表达式角色的具体实现类。实现文法中和终结符相关的解释操作，不再包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子角色（Leaf），可以有多种终结符解释器。

- 非终结符表达式（Nonterminal Expression）角色：

  抽象表达式角色的具体实现类。实现文法中和非终结符相关的解释操作，通常一个解释器对应一个语法规则，可以包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的树枝角色（Composite），可以有多种非终结符解释器

- 环境（Context）角色：

  也叫上下文，常用Hash Map来代替，通常包含解释器之外的一些全局信息（解释器需要的数据，或是公共的功能）。

- 客户端（Client）角色：

  构建文法表示的抽象语法树（Abstract Syntax Tree，该抽象语法树由终结符表达式和非终结符表达式的实例装配而成），并调用解释操作interpret()方法

### 相关模式

1) 解释器和组合模式

   通常解释器模式都会使用组合模式来实现，这样能够方便地构建抽象语法树。一般非终结符解释器相当于组合模式中的组合对象，终结符解释器相当于叶子对象。

2) 解释器模式和迭代器模式

   由于解释器模式通常使用组合模式来实现，因此在遍历整个对象结构时，可以使用迭代器模式。

3) 解释器模式和享元模式

   在使用解释器模式的时候，可能会造成多个细粒度对象，如各式各样的终结符解释器，而这些终结符解释器对不同的表达式来说是一样的，是可以共用的，因此可以引入享元模式来共享这些对象。

4) 解释器模式和访问者模式

   在解释器模式中，语法规则和解释器对象是有对应关系的。语法规则的变动意味着功能的变化。自然会导致使用不同的解释器对象；而且一个语法规则可以被不同的解释器解释执行。因此在构建抽象语法树的时候，如果每个节点所对应的解释器对象是固定的，这意味着该节点对应的功能是固定的，那么就不得不根据需要来构建不同的抽象语法树。为了让构建的抽象语法树较为通用，那就要求解释器的功能不要那么固定，要能很方便地改变解释器的功能，这个时候就变成了如何能够很方便地更改树形结构中节点对象的功能了，访问者模式可以很好的实现这个功能。 

### 总结

解释器模式的结构与组合模式相似，不过其包含的组成元素比组合模式多，而且组合模式是对象结构型模式，而解释器模式是类行为型模式。解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。在Jdk中的正则表达式中的Pattern类和Spring里面的Expression Parse接口使用的是解释器模式的思想。一个语言需要解释执行，且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释等可以使用解释器模式。整体来说还是一种应用较少的设计模式。

应用场景：

1) 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树

2) 一些重复出现的问题可以用一种简单的语言来表达

3) 一个简单语法需要解释的场景，比如编译器、运算表达式计算、正则表达式等

   在项目开发中，如果要对数据表达式进行分析与计算，无须再用解释器模式进行设计了，Java 提供了以下强大的数学公式解析器：Expression4J、MESP(Math Expression String Parser) 和**Jep（ Java expression parser ）**等，它们可以解释一些复杂的文法，功能强大，使用简单。也可以用SpringEL实现

解释器模式有以下优点:

1) 易于实现语法 

   一条语法规则用一个解释器对象来解释执行。对于解释器的实现来讲，功能就变得比较简单，只需要考虑这一条语法规则的实现就可以了，其他的都不用管。

2. 易于扩展新的语法

   正是由于采用一个解释器对象负责一条语法规则的方式，使得扩展新的语法非常容易。扩展了新的语法，只需要创建相应的解释器对象，在创建抽象语法树的时候使用这个新的解释器对象就可以了。

解释器模式有以下缺点:

1) 不适合复杂的语法

​      如果语法特别复杂，构建解释器模式需要的抽象语法树的工作是非常艰巨的，再加上有可能会需要构建多个抽象语法树。所以解释器模式不太适合于复杂的语法，对于复杂的语法，使用**语法分析程序**或**编译器生成器**可能会更好一些。 



## 迭代器模式（Iterator）

迭代器模式

### 说明

迭代器模式是一种对象行为型模式。提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。

### 角色

- 抽象迭代器角色（Iterator）：定义访问和遍历聚合元素的接口，通过包含hasNext()、first()、next()等方法
- 具体迭代器角色（Concrete Iterator）：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置
- 抽象聚合角色（Aggregate）：定义存储、添加、删除聚合对象以及创建迭代器对象的接口
- 具体聚合角色（Concrete Aggregate）：实现抽象聚合类，返回一个具体迭代器的实例
- 客户端角色（Client）：调用迭代器

### 总结

访问一个聚合对象的内容而无须暴露它的内部表示，把遍历任务交由迭代器完成，简化了聚合类。迭代器模式支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历，增加新的聚合类和迭代器类都很方便，无须修改原有代码，封装性良好。为遍历不同的聚合结构提供一个统一的接口。

应用场景

- 当需要为聚合对象提供多种遍历方式时
- 当需要为遍历不同的聚合结构提供一个统一的接口时
- 当访问一个聚合对象的内容而无须暴露其内部细节的表示时

## 中介者模式（Mediator）

中介者模式又称为调停者模式

### 说明

中介者模式是一种对象行为型模式，用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构 ，任何一个类的变动，只会影响类本身，以及中介者，这样就减小了系统的耦合。简单说就是引入一个“中介”，用于协调各个对象的关系，各个对象之间不用那么直白的直接调，对象只需要调用中介的方法，中介内部进行逻辑判断，由中介去调用各个对象的方法。

如果在一个系统中对象之间存在多对多的关系，可以将对象之间的一些交互行为的细节从各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。通过引入中介者来简化对象之间的复杂交互，中介者模式是“迪米特法则”的一个典型应用。

中介者模式的核心在于中介者类的引入，中介者类承担了两方面的职责： 

1) 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。

2) 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。
   

### 角色

- 抽象中介者（Mediator）角色：

  中介者的接口，定义了同事对象到中介者对象之间的接口，该接口用于与各同事对象之间的通信

- 具体中介者（Concrete Mediator）角色： 

  实现抽象中介者的方法，是抽象中介者的子类 。需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向其他具体的同事类发送信息。并协调各个同事角色之间的交互关系， 持有、维护各个同事对象的引用，通过协调各个同事对象来实现协作

- 抽象同事类（Colleague）角色：

  定义各个同事类中的公有的方法，并声明了一些抽象方法来供子类实现，同时持有一个抽象中介者的引用，子类通过中介者的引用来间接完成与其他同事类的通信

- 具体同事类（Concrete Colleague）角色： 

  抽象同事类的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法，所以每个具体同事类都只需要知道自己的行为即可。

### 总结

中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间**`松散耦合`**，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。多个同事对象的交互，被封装在中介者对象里面**`集中控制交互`**，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。

在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需要修改少许代码（如果引入配置文件的话有时可以不修改任何代码）就可以实现中介者的更换。

- 中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

使用场景：

1) 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解

2) 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象

3) 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类，如果需要改变行为则可以增加新的具体中介者类。
   

## 备忘录模式（Memento）

备忘录模式

### 说明

备忘录模式是一种对象行为模式。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，还可以将该对象恢复到原先保存的状态。

模式本质：保存和恢复状态

设计意图：将该对象恢复到原先保存的状态

### 角色

- 源发起（Originator）角色：

  需要保存状态的类，可以访问备忘录里的所有信息，记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能

- 备忘录（Memento）角色：

  保存源发起（Originator）对象状态，在需要的时候提供这些内部状态给源发起对象

- 守护者（Caretaker）角色：

  也叫负责人角色，提供保存与获取备忘录的功能，但不能对备忘录的内容进行访问与修改。
  
  若希望保存多个源发起（Originator）对象的不同时间的状态或者不同属性值，可以使用Hash Map实现

为了控制对备忘录对象的访问，备忘录模式中有两种设计方式：

1) 窄接口：

​		管理者只能看到备忘录的窄接口，窄接口的实现中通常没有任何的方法，只是一个类型标识。

​		窄接口使得守护对象只能将备忘录传递给其他对象。

2) 宽接口：

​		源发起对象能够看到备忘录的宽接口，从而可以从备忘录中获取到所需的数据，来将自己恢复到备忘录中所保存的状态。

​		理想情况是：只允许生成备忘录的源发起对象访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类。

### 总结

备忘录模式提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能够访问这些状态信息。简化了源发起角色，源发起角色不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由守护者进行管理，这符合单一职责原则。但是如果需要保存的内部状态过多或操作备忘录过于频繁，会占用较大的资源。

使用场景：

1) 需要保存与恢复数据
2) 需要提供一个可回滚操作

常见应用场景：

1) 棋类游戏中的悔棋
2) 软件中的撤销操作
3) 数据库的事务管理中的回滚操作
4) 软件中的历史记录

## 观察者模式（Observer）

观察者模式又叫`发布-订阅(Publish/Subscribe)模式`、`模型-视图(Model/View)模式`、`源-监听器(Source/Listener)模式`或`从属者(Dependents)模式`。

### 说明

观察者模式是对象的行为模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

在观察者模式中，又分为推模型和拉模型两种方式。

- 推模型

  主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。推模型是假定主题对象知道观察者需要的数据，通过update方法中的参数传递给观察者。推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者

- 拉模型

  主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身（this）通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。拉模型不会造成观察者对象难以复用的情况，因为update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

### 角色

- 抽象主题(Subject)角色：又叫做抽象被观察者(Observable)角色。它把所有观察者对象（Observer）保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者（Observable）。抽象主题角色提供一个接口，可以增加和删除观察者对象。

- 具体主题(Concrete Subject)角色：具又叫做具体被观察者(Concrete Observable)角色。将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者（Observer）发出通知。

- 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

- 具体观察者(Concrete Observer)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。

### 总结

虽然观察者模式的概念是：一对多的依赖关系，但不一定观察者有多个才能使用，观察者模式很好的降低了目标与观察者之间的耦合关系，使得目标与观察者建立了一套触发机制，从而让各自的变换都不会影响另一边的变换，也成为了最常见的设计模式。

使用场景：

1) 一个对象的改变会导致一个或多个对象发生改变，而并不知道具体有多少对象将会发生改变，也不知道这些对象是谁。
2) 一个抽象模型有两个维度，而且一个维度（Observer）依赖另一个维度（Subject），可将这两者封装在一个独立的对象（Concrete Subject）中，让其可以各自独立地改变和复用，并可以让一个维度的状态改变（Subject）通知另一个维度（Observer）。
3) 需要在系统中创建一个触发链，使得事件可以通知多种观察者类型。

典型应用：

1) 聊天室程序，服务器转发给所有客户端
2) 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发
3) 邮件订阅
4) Servlet中，监听器的实现
5) Android中，广播机制
6) 电商中，群发某商品打折信息
7) Redis 中的基于频道的发布订阅

## 原型模式（Prototype）

原型模式

### 说明

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 代理模式（Proxy）

代理模式

## 单例模式（Singleton）

单例模式

## 状态模式（State）

状态模式也叫作状态机模式

### 说明

状态模式属于行为型设计模式。运行对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。状态模式中类的行为是由状态决定的，在不同的状态下有不同的行为。

- 设计意图：让一个对象在其内部改变的时候，行为也随之改变。
- 模式核心：状态与行为绑定，不同的状态对应不同的行为。

状态机有三个组成部分：状态、事件和动作。触发某个事件可以改变对象的状态。

### 角色

- 抽象状态（State）角色：

  接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。

- 具体状态（Concrete State）角色：

  每个具体状态角色必须完成两个职责：本状态的行为处理和趋向状态处理，就是本状态下要做的事和本状态如何过渡到其他状态。

- 环境（Context）角色：

  定义客户端需要的接口，并且负责具体状态的切换。

  环境角色有两个不成文的约束：

  - 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。
  - 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。

### 总结

避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，将对象的状态变换放置到类的内部来实现，结构清晰，外部的调用不用知道类内部是如何实现状态和行为的变换的。行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过五个。

使用场景：

1) 行为随状态改变而改变的场景

   这是状态模式的根本出发点。

   如权限设计：人员的状态不同即使执行相同的行为结果也会不同，这种情况下可以考虑使用状态模式。

2) 替代条件、分支判断语句，并且这些分支取决于对象的状态

   程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，状态模式通过扩展子类实现了条件的判断处理。

状态模式和策略模式的类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，**彼此之间是独立的**，用户可自行更换策略算法；而状态模式的各个状态之间存在相互关系，彼此之间一定的条件下存在自动切换的效果，并且用户无法指定状态，**只能设置初始状态**，因为状态是根据行为而改变的。

## 策略模式（Strategy）

策略模式

### 说明

定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以代替多重`if-else`和`switch`语句，将对象和行为分开，将行为定义为 一个行为接口和具体行为的实现，每个if判断都可以理解为一个策略，让代码维护变得更加简单，。

### 角色

- 抽象策略（Strategy）角色：

  接口或抽象类，定义若干个算法标识，即若干个抽象方法

- 具体策略（Concrete Strategy）角色：

  抽象策略角色的子类，实现了抽象策略定义的抽象方法（实现相关的算法、行为）

- 环境类 /上下文（Context）角色：

  持有一个策略角色的引用并提供一个方法给客户端调用，该方法委托执行具体策略角色的方法

### 总结

与状态模式对比：

1) 策略模式各个策略之间并不存在**流转**关系，都是各自的算法实现各自的逻辑，由客户端选择调用的策略，调用完成后就结束了。

2) 策略模式调用哪个策略由客户端决定；状态模式中，客户端只管调用，由各个具体状态类来切换下一状态。

3) 状态模式强调状态变化、策略模式强调的是策略的选择。

使用场景

1) 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。

2) 一个类定义了多种行为，这些行为在操作中以多个条件语句的形式出现，可将每个条件移入各自的策略类中代替这些条件语句。

3) 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。

4) 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。

5) 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。

## 模板方法模式（Template Method）

模板方法模式又叫做虚拟构造子模式或者多态性工厂模式

### 说明

定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。

### 角色

- 抽象类（Abstract Class）角色：

  负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

  - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法；

  - 基本方法：是实现算法各个步骤的方法。

    基本方法又可以分为三种：

    - 抽象方法（Abstract Method）：一个抽象方法由抽象类声明、由其具 体子类实现；
    - 具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承；
    - 钩子方法（Hook Method）：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

- 具体子类（Concrete Class）角色：

  实现抽象类中所定义的抽象方法和钩子方法，它们是抽象类中定义的算法的组成步骤。

### 总结

模板方法模式提高了代码的复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中，而且实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。但是对每个不同的实现都需要定义一个子类，这会导致类的个数增加，设计变的更加抽象。又因为是反向控制结构，所以提高了代码阅读的难度。

使用场景

1) 算法的整体步骤很固定，但其中个别部分容易变动，这时可以使用模板方法模式，将容易变动的部分抽象出来，让子类实现；
2) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。

## 访问者模式（Visitor）

访问者模式（号称是最复杂的设计模式）

### 说明

访问者模式是对象行为型设计模式。将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。系统中有一些固定结构的对象（元素），在对象内部提供一个accept()方法接受访问者对象的访问，不同的访问者对同一元素的访问内容不同，所以相同的元素可以产生不同的访问结果。

- 设计意图：将数据操作与数据结构分离

- 设计目的：封装一些施加于某种数据结构元素之上的操作，当操作需要修改时，数据结构保持不变

举个例子：

您（Concrete Visitor）去朋友家做客，朋友（Concrete Element）接受了（accept）您的访问，您通过朋友的描述（visit），然后对朋友的描述做出一个判断，这就是访问者模式。

### 角色

- 抽象元素（Element）角色：

  定义一个接受访问的方法（如：accept），参数为访问者（Visitor）对象。

- 具体元素（Concrete Element）角色：

  提供接受访问者访问的具体实现，调用访问者的visit()，并定义额外的数据操作方法。

- 抽象访问者（Visitor）角色：

  声明一个或者多个方法操作，形成所有的具体访问者角色必须实现的接口。

  这个角色主要是定义对具体元素的访问方法visit()，理论上来说方法数等于元素（固定类型的对象，也就是被访问者）个数。

- 具体访问者（Concrete Visitor）角色：

  实现对具体元素的访问visit方法，参数就是具体元素。

- 结构对象（Object Structure）角色：

  提供一个方法来访问所有的元素，可以提供一个高层接口允许访问者访问它的元素；如有需要，可以设计成一个复合对象或者一个聚集（如一个列表或无序集合）。

### 总结

能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能，并通过访问者来定义整个对象结构通用的功能，从而提高复用程度，还可以使用访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。

不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高，而且通常需要对象结构开放内部数据给访问者和Object Structure，破坏了对象的封装性。



使用场景：

1) 类中包含各种类型的元素，类结构比较稳定，元素类型不会经常变动，但是频繁需要给这些元素添加新的操作
2) 需要对一个对象结构中的对象进行很多不同的且不相关的操作，而且需要避免让这些操作"污染"这些对象的类（分离出操作）
3) 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器。

4) JDK的NIO中的 FileVisitor接口采用的就是访问者模式。

### 扩展

1) 分派：

   根据对象的类型而对方法进行的选择，就是分派（Dispatch），分派又分为两种，静态分派和动态分派

   - 静态分派（Static Dispatch）:

     发生在编译时期，分派根据静态类型信息发生。方法重载就是静态分派。

     ```java
     public class Animal {
     }
     public class Dog extends Animal {
     }
     public class Cat extends Animal {
     }
     public class Execute {
         public void execute(Animal a) {
             System.out.println("Animal");
         }
         public void execute(Dog d) {
             System.out.println("dog");
         }
         public void execute(Cat c) {
             System.out.println("cat");
         }
     }
     public class Client {
         public static void main(String[] args) {
             Animal a = new Animal();
             Animal a1 = new Dog();
             Animal a2 = new Cat();
             Execute exe = new Execute();
             exe.execute(a);
             exe.execute(a1);
             exe.execute(a2);
         }
     }
     ```

     上面的程序执行结果为：

     ```java
     Animal
     Animal
     Animal    
     ```

     不管在运行的时候传入的实际类型是什么，它永远都只会执行 execute(Animal a)这个方法，即 : 重载是静态绑定，**重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。**

   - 动态分派（Dynamic Dispatch）：

     发生在运行时期，动态分派动态地置换掉某个方法，Java通过方法的重写支持动态分派（多态）。
     ```java
     public class Animal {
         public void execute() {
             System.out.println("Animal");
         }
     }
     public class Dog extends Animal {
         @Override
         public void execute() {
             System.out.println("dog");
         }
     }
     public class Cat extends Animal {
         @Override
         public void execute() {
             System.out.println("cat");
         }
     }
     public class Client {
         public static void main(String[] args) {
             Animal a = new Dog();
             a.execute();
             Animal a1 = new Cat();
             a1.execute();
         }
     }
     ```

     运行结果如下：

     ```java
     dog
     cat    
     ```

     Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。

2. 人为实现动态绑定

   如果希望使用重载的时候，程序能够根据传入参数的实际类型动态地调用相应的方法，也就是说，我们希望Java的重载是动态的，而不是静态的。但是由于Java的重载不是动态绑定，只能通过程序来人为判断，我们一般会使用instanceof操作符来进行类型的判断

   ``` java
   public class Animal {
   }
   public class Dog extends Animal {
   }
   public class Cat extends Animal {
   }
   public class Execute {
       public void execute(Animal a) {
           if (a instanceof Dog) {
               System.out.println("dog");
           } else if (a instanceof Cat) {
               System.out.println("cat");
           } else {
               System.out.println("Animal");
           }  
       }
       public void execute(Dog d) {
           System.out.println("dog");
       }
       public void execute(Cat c) {
           System.out.println("cat");
       }
   }
   public class Client {
       public static void main(String[] args) {
           Animal a = new Animal();
           Animal a1 = new Dog();
           Animal a2 = new Cat();
           Execute exe = new Execute();
           exe.execute(a);
           exe.execute(a1);
           exe.execute(a2);
       }
   }
   ```

   运行结果：

   ```java
   Animal
   dog
   cat    
   ```

   这种方式是伪动态的，仍然需要通过程序来判断类型。假如有很多个子类的话，还是这样来实现显然是不合适的，必须通过其他方式实现，我们可以使用双分派方式来实现动态绑定

3) 双分派

   所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。
   
   ```java
   public class Animal {
       public void accept(Execute exe) {
           exe.execute(this);
       }
   }
   public class Dog extends Animal {
       public void accept(Execute exe) {
           exe.execute(this);
       }
   }
   public class Cat extends Animal {
       public void accept(Execute exe) {
           exe.execute(this);
       }
   }
   public class Execute {
       public void execute(Animal a) {
           System.out.println("animal");
       }
       public void execute(Dog d) {
           System.out.println("dog");
       }
       public void execute(Cat c) {
           System.out.println("cat");
       }
   }
   public class Client {
       public static void main(String[] args) {
           Animal a = new Animal();
           Animal d = new Dog();
           Animal c = new Cat();
           Execute exe = new Execute();
           a.accept(exe);
           d.accept(exe);
           c.accept(exe);
       }
   }
   ```
   
   运行结果如下：
   
   ```java
   animal
   dog
   cat   
   ```

   客户端**将Execute对象做为参数传递给Animal类型的变量的accept方法，这里完成第一次分派**，因为是方法重写，所以是动态分派，也就是子类去执行accept()方法；子类执行accept方法时反向调用Execute的象并**将自己（this）作为参数传递给Execute对象的execute方法，这里完成了第二次分派**。Execute类中有多个重载的方法，**而传递的是this**，就是具体的实际类型（子类）的对象，所以也是动态分派。
   
   **双分派是实现动态绑定的本质。客户端调用方法（accept）时由于Java的多态，实际是由子类来执行，执行时子类再调用重载方法（execute）时传的是自己（this），也就是子类的类型，所以重载就是（看起来）动态的了。**

## 装饰者模式（Wrapper）

装饰者模式（包装模式）

