# DesignPattern

设计模式

## 适配器模式（Adapter）

适配器模式

### 说明

可以让一个类在两个独立的维度变化，这两个维度都可以进行扩展，适配器模式只在一个维度实现继承，所以不会因为多维度、多层次继承导致系统类的个数急剧增加，这就让构件的抽象化角色和具体化角色之间增加了更多的灵活性。

### 角色

- Abstraction：抽象类。

- RefinedAbstraction：扩充抽象类。

- Implementor：实现类接口。

- ConcreteImplementor：具体实现类 。

### 说明

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

### 角色

- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

- 需要适配的类（Adaptee）：需要适配的类或适配者类。

- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

## 桥接模式（Bridge）

桥接模式

## 建造者模式（Builder）

建造者模式

### 说明

**以下情况建议使用建造者模式**

- 某个对象有复杂的内部结构，通常包含多个成员属性，而且属性是可选的。

- 相同的方法，不同的执行顺序，产生不同的对象或不同的运行结果。

- 当创建一个对象需要很多步骤时，适合使用建造者模式。

## 责任链模式（Chain Of Responsibility）

责任链模式

## 组合模式（Composite）

组合模式

### 说明

组合(Composite)模式是一种对象的行为模式。将对象组合成`树形结构`以表示`部分--整体`的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。组合模式又可以称为`整体—部分(Part-Whole)模式`，它是一种对象结构型模式。

- 组合模式的本质：统一叶子对象和组合对象。

- 组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

### 角色

- 抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，
  可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里， 
  构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
- 树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
- 树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，
  如add()、remove()以及getChild()。

### 实现方式

#### 1、安全性组合模式

从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。

#### 2、透明性组合模式

从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。

### 总结

对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用合成模式的时候，建议多采用透明性的实现方式。

## 外观模式（Facade）

外观模式，又叫门面模式。

### 说明

 一个复杂的过程需要高级的接口以及具体实现的实现类，对于调用者来说并不关心实现的细节，只关心结果调用和结果输出。可以拆分子系统，或者用单独的类进行构造门面模式。通过定义一个一致的接口,用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

### 角色

- 外观(Facade)角色：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求

  从而将调用端的请求代理给适当子系统对象。

- 客户端(Client)角色：外观接口的调用者。

- 子系统(SubSystem)角色：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

### 总结

外观模式并不符合`开闭原则`，需要修改原来的接口代码进行改造。

外观模式的注意事项和细节：

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性；

2. 外观模式对客户端与子系统的耦合关系进行解耦，让子系统内部的模块更易维护和扩展；

3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次；

4. 当系统`需要进行分层设计`时，可以考虑使用Facade模式；

5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，

   此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 

   让新系统与Facade类交互，提高复用性；

6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

## 工厂模式（Factory）

工厂模式

## 原型模式（Prototype）

原型模式

### 说明

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 代理模式（Proxy）

代理模式

## 单例模式（Singleton）

单例模式

## 装饰者模式（Wrapper）

装饰者模式（包装模式）

