# 设计模式 Design Pattern

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

设计模式分为三种类型，共23种：

- **创建型模式**：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
- **结构型模式**：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- **行为型模式**：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。

## 适配器模式（Adapter）

适配器模式

### 说明

可以让一个类在两个独立的维度变化，这两个维度都可以进行扩展，适配器模式只在一个维度实现继承，所以不会因为多维度、多层次继承导致系统类的个数急剧增加，这就让构件的抽象化角色和具体化角色之间增加了更多的灵活性。

### 角色

- Abstraction：抽象类。

- RefinedAbstraction：扩充抽象类。

- Implementor：实现类接口。

- ConcreteImplementor：具体实现类 。

### 说明

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

### 角色

- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

- 需要适配的类（Adaptee）：需要适配的类或适配者类。

- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

## 桥接模式（Bridge）

桥接模式

## 建造者模式（Builder）

建造者模式

### 说明

**以下情况建议使用建造者模式**

- 某个对象有复杂的内部结构，通常包含多个成员属性，而且属性是可选的。

- 相同的方法，不同的执行顺序，产生不同的对象或不同的运行结果。

- 当创建一个对象需要很多步骤时，适合使用建造者模式。

## 责任链模式（Chain Of Responsibility）

责任链模式

## 命令模式（Command）

命令模式又叫动作（Action）模式或事务（Transaction）模式。

### 说明

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

- 命令模式的本质：命令发出者不知道最终的执行者是谁，实现命令发出者与执行者之间的解耦，让请求与执行进行分离
- 命令模式的目的：将一个请求封装到一个对象中，实现用不同的请求对客户端参数化

### 角色

- 抽象命令（Command）角色：封装一个普适方法，定义命令的接口，声明执行的方法

- 具体命令（Concrete Command）角色：具体的命令，实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作

- 接受者（Receiver）角色：真正执行命令的对象，只要它能够实现命令要求实现的相应功能

  Receiver可以是任意类型，包括：

  ①固定的具体类

  ②抽象类型，真正执行命令的对象是其子类

  ③临时的接受者，以匿名类或lambda表达式的形式传入

- 请求者（Invoker）角色：调用命令对象执行请求，通常会持有命令对象，也可以持有很多的命令对象，相当于客户端使用命令对象的入口

### 总结

Invoker不知道应该依赖谁，因此依赖封装普适方法execute()的命令；execute()作为适配目标，Command模式是适配器模式的特例。

## 组合模式（Composite）

组合模式

### 说明

组合(Composite)模式是一种对象的行为模式。将对象组合成`树形结构`以表示`部分--整体`的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。组合模式又可以称为`整体—部分(Part-Whole)模式`，它是一种对象结构型模式。

- 组合模式的本质：统一叶子对象和组合对象。

- 组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

### 角色

- 抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，
  可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里， 
  构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
- 树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
- 树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，
  如add()、remove()以及getChild()。

### 实现方式

#### 1、安全性组合模式

从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。

#### 2、透明性组合模式

从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。

### 总结

对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用合成模式的时候，建议多采用透明性的实现方式。

## 外观模式（Facade）

外观模式，又叫门面模式。

### 说明

 一个复杂的过程需要高级的接口以及具体实现的实现类，对于调用者来说并不关心实现的细节，只关心结果调用和结果输出。可以拆分子系统，或者用单独的类进行构造门面模式。通过定义一个一致的接口,用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

### 角色

- 外观(Facade)角色：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求

  从而将调用端的请求代理给适当子系统对象。

- 客户端(Client)角色：外观接口的调用者。

- 子系统(SubSystem)角色：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

### 总结

外观模式并不符合`开闭原则`，需要修改原来的接口代码进行改造。

外观模式的注意事项和细节：

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性；

2. 外观模式对客户端与子系统的耦合关系进行解耦，让子系统内部的模块更易维护和扩展；

3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次；

4. 当系统`需要进行分层设计`时，可以考虑使用Facade模式；

5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，

   此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 

   让新系统与Facade类交互，提高复用性；

6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

## 工厂模式（Factory）

工厂模式

## 享元模式（Flyweight）

享元模式

### 说明

享元模式（Flyweight）又称为轻量级模式，它是一种对象结构型模式。很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。

享元模式是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。

享元模式 把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。

- 享元模式的本质：缓存共享对象，降低内存消耗

- 享元模式的目的：当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多处需要使用的地方，避免大量同一对象的多次创建，消耗大量内存空间。

享元模式其实就是 工厂模式 的一个改进机制，享元模式 同样要求创建一个或一组对象，并且就是通过工厂方法生成对象的，只不过 享元模式 中为工厂方法增加了缓存这一功能。

### 角色

- 抽象享元（Flyweight）角色：享元对象的抽象，定义了对象的外部状态和内部状态的接口或实现
- 享元（Concrete Flyweight）角色：具体的享元角色，抽象享元的实现类，实现了抽象角色定义的相关业务
- 享元工厂（Flyweight Factory）角色：享元工厂类，内部提供一个池容器，储存Concrete Flyweight，提供从池中存取数据的操作

### 总结

享元模式通常与工厂模式一起使用，可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低内存占用，增强程序的性能。享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享；但是这种模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化，而且为了使对象可以共享，需要将享元对象的外部状态必须具备固化特性，即不应该随内部状态改变而改变，否则会导致系统的逻辑混乱。

使用场景

- 系统中存在大量的相同或相似对象；
- 对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份；
- 需要缓冲池的场景；
- 在Java中，数据库连接池，线程池等即是享元模式的应用。

## 原型模式（Prototype）

原型模式

### 说明

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 代理模式（Proxy）

代理模式

## 单例模式（Singleton）

单例模式

## 模板方法模式（Template Method）

模板方法模式又叫做虚拟构造子模式或者多态性工厂模式

### 说明

定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。

### 角色

- 抽象类（Abstract Class）角色：

  负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

  - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法；

  - 基本方法：是实现算法各个步骤的方法。

    基本方法又可以分为三种：

    - 抽象方法（Abstract Method）：一个抽象方法由抽象类声明、由其具 体子类实现；
    - 具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承；
    - 钩子方法（Hook Method）：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

- 具体子类（Concrete Class）角色：

  实现抽象类中所定义的抽象方法和钩子方法，它们是抽象类中定义的算法的组成步骤。

### 总结

模板方法模式提高了代码的复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中，而且实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。但是对每个不同的实现都需要定义一个子类，这会导致类的个数增加，设计变的更加抽象。又因为是反向控制结构，所以提高了代码阅读的难度。

使用场景

1) 算法的整体步骤很固定，但其中个别部分容易变动，这时可以使用模板方法模式，将容易变动的部分抽象出来，让子类实现；

2) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。

## 装饰者模式（Wrapper）

装饰者模式（包装模式）

