# 设计模式 Design Pattern

设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。

设计模式分为三种类型，共23种：

- **创建型模式**：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
- **结构型模式**：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
- **行为型模式**：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式、访问者模式。

## 适配器模式（Adapter）

适配器模式

### 说明

可以让一个类在两个独立的维度变化，这两个维度都可以进行扩展，适配器模式只在一个维度实现继承，所以不会因为多维度、多层次继承导致系统类的个数急剧增加，这就让构件的抽象化角色和具体化角色之间增加了更多的灵活性。

### 角色

- Abstraction：抽象类。

- RefinedAbstraction：扩充抽象类。

- Implementor：实现类接口。

- ConcreteImplementor：具体实现类 。

### 说明

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

### 角色

- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

- 需要适配的类（Adaptee）：需要适配的类或适配者类。

- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

## 桥接模式（Bridge）

桥接模式

## 建造者模式（Builder）

建造者模式

### 说明

**以下情况建议使用建造者模式**

- 某个对象有复杂的内部结构，通常包含多个成员属性，而且属性是可选的。

- 相同的方法，不同的执行顺序，产生不同的对象或不同的运行结果。

- 当创建一个对象需要很多步骤时，适合使用建造者模式。

## 责任链模式（Chain Of Responsibility）

责任链模式

## 命令模式（Command）

命令模式又叫动作（Action）模式或事务（Transaction）模式。

### 说明

命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。命令模式将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。

- 命令模式的本质：命令发出者不知道最终的执行者是谁，实现命令发出者与执行者之间的解耦，让请求与执行进行分离
- 命令模式的目的：将一个请求封装到一个对象中，实现用不同的请求对客户端参数化

### 角色

- 抽象命令（Command）角色：封装一个普适方法，定义命令的接口，声明执行的方法

- 具体命令（Concrete Command）角色：具体的命令，实现命令接口，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作

- 接受者（Receiver）角色：真正执行命令的对象，只要它能够实现命令要求实现的相应功能

  Receiver可以是任意类型，包括：

  ①固定的具体类

  ②抽象类型，真正执行命令的对象是其子类

  ③临时的接受者，以匿名类或lambda表达式的形式传入

- 请求者（Invoker）角色：调用命令对象执行请求，通常会持有命令对象，也可以持有很多的命令对象，相当于客户端使用命令对象的入口

### 总结

Invoker不知道应该依赖谁，因此依赖封装普适方法execute()的命令；execute()作为适配目标，Command模式是适配器模式的特例。

可以用过程语言中的回调（callback）函数表达这种参数化机制，命令模式是回调机制的一个面向对象的替代品。

使用场景：

1) 界面的一个按钮都是一条命令、模拟CMD（DOS命令）命令、 订单的撤销/恢复、触发-反馈机制
2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象（Concrete Command）和请求的调用者（Invoker）可以有不同的生命期，换言之，请求调用者（Invoker）可能已经不在了，而命令对象（Concrete Command）本身仍然是活动的，可以通过该命令对象去调用请求接收者（Receiver），而无须关心请求调用者（Invoker）的存在性，可以通过请求日志文件等机制来具体实现
3) 系统需要将请求调用者（Invoker）和请求接收者（Receiver）解耦，使得调用者（Invoker）和接收者（Receiver）不直接交互。请求调用者（Invoker）无须知道接收者（Receiver）的存在，也无须知道接收者（Receiver）是谁，接收者（Receiver）也无须关心何时被调用
4) 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作
5) 系统需要将一组操作组合在一起形成宏命令。认为是命令的地方都可以使用命令模式，比如： GUI 中每一个按钮都是一条命令。

## 组合模式（Composite）

组合模式

### 说明

组合(Composite)模式是一种对象的行为模式。将对象组合成`树形结构`以表示`部分--整体`的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。组合模式又可以称为`整体—部分(Part-Whole)模式`，它是一种对象结构型模式。

- 组合模式的本质：统一叶子对象和组合对象。

- 组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。

### 角色

- 抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，
  可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里， 
  构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。
- 树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。
- 树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，
  如add()、remove()以及getChild()。

### 实现方式

#### 1、安全性组合模式

从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。

#### 2、透明性组合模式

从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。

### 总结

对于合成模式而言，在安全性和透明性上，会更看重透明性，毕竟合成模式的目的是让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。而对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。因此在使用合成模式的时候，建议多采用透明性的实现方式。

## 外观模式（Facade）

外观模式，又叫门面模式。

### 说明

 一个复杂的过程需要高级的接口以及具体实现的实现类，对于调用者来说并不关心实现的细节，只关心结果调用和结果输出。可以拆分子系统，或者用单独的类进行构造门面模式。通过定义一个一致的接口,用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。

### 角色

- 外观(Facade)角色：为调用端提供统一的调用接口，外观类知道哪些子系统负责处理请求

  从而将调用端的请求代理给适当子系统对象。

- 客户端(Client)角色：外观接口的调用者。

- 子系统(SubSystem)角色：指模块或者子系统，处理Facade对象指派的任务，他是功能的实际提供者。

### 总结

外观模式并不符合`开闭原则`，需要修改原来的接口代码进行改造。

外观模式的注意事项和细节：

1. 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复 杂性；

2. 外观模式对客户端与子系统的耦合关系进行解耦，让子系统内部的模块更易维护和扩展；

3. 通过合理的使用外观模式，可以帮我们更好的划分访问的层次；

4. 当系统`需要进行分层设计`时，可以考虑使用Facade模式；

5. 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，

   此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口， 

   让新系统与Facade类交互，提高复用性；

6) 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以让系统有层次，利于维护为目的。

## 工厂模式（Factory）

工厂模式

## 享元模式（Flyweight）

享元模式

### 说明

享元模式（Flyweight）又称为轻量级模式，它是一种对象结构型模式。很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式正是为解决这一类问题而诞生的。

享元模式是对象池的一种实现。类似于线程池，线程池可以避免不停的创建和销毁多个对象，消耗性能。享元模式也是为了减少内存的使用，避免出现大量重复的创建销毁对象的场景。

享元模式 把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。

- 享元模式的本质：缓存共享对象，降低内存消耗

- 享元模式的目的：当系统中多处需要同一组信息时，可以把这些信息封装到一个对象中，然后对该对象进行缓存，这样，一个对象就可以提供给多处需要使用的地方，避免大量同一对象的多次创建，消耗大量内存空间。

享元模式其实就是 工厂模式 的一个改进机制，享元模式 同样要求创建一个或一组对象，并且就是通过工厂方法生成对象的，只不过 享元模式 中为工厂方法增加了缓存这一功能。

### 角色

- 抽象享元（Flyweight）角色：享元对象的抽象，定义了对象的外部状态和内部状态的接口或实现
- 享元（Concrete Flyweight）角色：具体的享元角色，抽象享元的实现类，实现了抽象角色定义的相关业务
- 享元工厂（Flyweight Factory）角色：享元工厂类，内部提供一个池容器，储存Concrete Flyweight，提供从池中存取数据的操作

### 总结

享元模式通常与工厂模式一起使用，可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份，降低内存占用，增强程序的性能。享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享；但是这种模式需要分离出内部状态和外部状态，这使得程序的逻辑复杂化，而且为了使对象可以共享，需要将享元对象的外部状态必须具备固化特性，即不应该随内部状态改变而改变，否则会导致系统的逻辑混乱。

使用场景

- 系统中存在大量的相同或相似对象；
- 对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份；
- 需要缓冲池的场景；
- 在Java中，数据库连接池，线程池等即是享元模式的应用。

## 迭代器模式（Iterator）

迭代器模式

### 说明

迭代器模式是一种对象行为型模式。提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。

### 角色

- 抽象迭代器角色（Iterator）：定义访问和遍历聚合元素的接口，通过包含hasNext()、first()、next()等方法
- 具体迭代器角色（Concrete Iterator）：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置
- 抽象聚合角色（Aggregate）：定义存储、添加、删除聚合对象以及创建迭代器对象的接口
- 具体聚合角色（Concrete Aggregate）：实现抽象聚合类，返回一个具体迭代器的实例
- 客户端角色（Client）：调用迭代器

### 总结

访问一个聚合对象的内容而无须暴露它的内部表示，把遍历任务交由迭代器完成，简化了聚合类。迭代器模式支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历，增加新的聚合类和迭代器类都很方便，无须修改原有代码，封装性良好。为遍历不同的聚合结构提供一个统一的接口。

应用场景

- 当需要为聚合对象提供多种遍历方式时
- 当需要为遍历不同的聚合结构提供一个统一的接口时
- 当访问一个聚合对象的内容而无须暴露其内部细节的表示时

## 中介者模式（Mediator）

中介者模式又称为调停者模式

### 说明

中介者模式是一种对象行为型模式，用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构 ，任何一个类的变动，只会影响类本身，以及中介者，这样就减小了系统的耦合。简单说就是引入一个“中介”，用于协调各个对象的关系，各个对象之间不用那么直白的直接调，对象只需要调用中介的方法，中介内部进行逻辑判断，由中介去调用各个对象的方法。

如果在一个系统中对象之间存在多对多的关系，可以将对象之间的一些交互行为的细节从各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。通过引入中介者来简化对象之间的复杂交互，中介者模式是“迪米特法则”的一个典型应用。

中介者模式的核心在于中介者类的引入，中介者类承担了两方面的职责： 

1) 中转作用（结构性）：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。

2) 协调作用（行为性）：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。
   

### 角色

- 抽象中介者（Mediator）角色：

  中介者的接口，定义了同事对象到中介者对象之间的接口，该接口用于与各同事对象之间的通信

- 具体中介者（Concrete Mediator）角色： 

  实现抽象中介者的方法，是抽象中介者的子类 。需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向其他具体的同事类发送信息。并协调各个同事角色之间的交互关系， 持有、维护各个同事对象的引用，通过协调各个同事对象来实现协作

- 抽象同事类（Colleague）角色：

  定义各个同事类中的公有的方法，并声明了一些抽象方法来供子类实现，同时持有一个抽象中介者的引用，子类通过中介者的引用来间接完成与其他同事类的通信

- 具体同事类（Concrete Colleague）角色： 

  抽象同事类的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法，所以每个具体同事类都只需要知道自己的行为即可。

### 总结

中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间**`松散耦合`**，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。多个同事对象的交互，被封装在中介者对象里面**`集中控制交互`**，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。

在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需要继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需要继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需要修改少许代码（如果引入配置文件的话有时可以不修改任何代码）就可以实现中介者的更换。

- 中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。

使用场景：

1) 系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解

2) 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象

3) 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类，如果需要改变行为则可以增加新的具体中介者类。
   

## 备忘录模式（Memento）

备忘录模式

### 说明

备忘录模式是一种对象行为模式。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，还可以将该对象恢复到原先保存的状态。

模式本质：保存和恢复状态

设计意图：将该对象恢复到原先保存的状态

### 角色

- 源发起（Originator）角色：

  需要保存状态的类，可以访问备忘录里的所有信息，记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能

- 备忘录（Memento）角色：

  保存源发起（Originator）对象状态，在需要的时候提供这些内部状态给源发起对象

- 守护者（Caretaker）角色：

  也叫负责人角色，提供保存与获取备忘录的功能，但不能对备忘录的内容进行访问与修改。
  
  若希望保存多个源发起（Originator）对象的不同时间的状态或者不同属性值，可以使用Hash Map实现

为了控制对备忘录对象的访问，备忘录模式中有两种设计方式：

1) 窄接口：

​		管理者只能看到备忘录的窄接口，窄接口的实现中通常没有任何的方法，只是一个类型标识。

​		窄接口使得守护对象只能将备忘录传递给其他对象。

2) 宽接口：

​		源发起对象能够看到备忘录的宽接口，从而可以从备忘录中获取到所需的数据，来将自己恢复到备忘录中所保存的状态。

​		理想情况是：只允许生成备忘录的源发起对象访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类。

### 总结

备忘录模式提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。实现了内部状态的封装，除了创建它的发起人之外，其他对象都不能够访问这些状态信息。简化了源发起角色，源发起角色不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由守护者进行管理，这符合单一职责原则。但是如果需要保存的内部状态过多或操作备忘录过于频繁，会占用较大的资源。

使用场景：

1) 需要保存与恢复数据
2) 需要提供一个可回滚操作

常见应用场景：

1) 棋类游戏中的悔棋
2) 软件中的撤销操作
3) 数据库的事务管理中的回滚操作
4) 软件中的历史记录

## 观察者模式（Observer）

观察者模式又叫`发布-订阅(Publish/Subscribe)模式`、`模型-视图(Model/View)模式`、`源-监听器(Source/Listener)模式`或`从属者(Dependents)模式`。

### 说明

观察者模式是对象的行为模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

在观察者模式中，又分为推模型和拉模型两种方式。

- 推模型

  主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。推模型是假定主题对象知道观察者需要的数据，通过update方法中的参数传递给观察者。推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者

- 拉模型

  主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身（this）通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。拉模型不会造成观察者对象难以复用的情况，因为update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

### 角色

- 抽象主题(Subject)角色：又叫做抽象被观察者(Observable)角色。它把所有观察者对象（Observer）保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者（Observable）。抽象主题角色提供一个接口，可以增加和删除观察者对象。

- 具体主题(Concrete Subject)角色：具又叫做具体被观察者(Concrete Observable)角色。将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者（Observer）发出通知。

- 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

- 具体观察者(Concrete Observer)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。

### 总结

虽然观察者模式的概念是：一对多的依赖关系，但不一定观察者有多个才能使用，观察者模式很好的降低了目标与观察者之间的耦合关系，使得目标与观察者建立了一套触发机制，从而让各自的变换都不会影响另一边的变换，也成为了最常见的设计模式。

使用场景：

1) 一个对象的改变会导致一个或多个对象发生改变，而并不知道具体有多少对象将会发生改变，也不知道这些对象是谁。
2) 一个抽象模型有两个维度，而且一个维度（Observer）依赖另一个维度（Subject），可将这两者封装在一个独立的对象（Concrete Subject）中，让其可以各自独立地改变和复用，并可以让一个维度的状态改变（Subject）通知另一个维度（Observer）。
3) 需要在系统中创建一个触发链，使得事件可以通知多种观察者类型。

典型应用：

1) 聊天室程序，服务器转发给所有客户端
2) 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发
3) 邮件订阅
4) Servlet中，监听器的实现
5) Android中，广播机制
6) 电商中，群发某商品打折信息
7) Redis 中的基于频道的发布订阅

## 原型模式（Prototype）

原型模式

### 说明

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## 代理模式（Proxy）

代理模式

## 单例模式（Singleton）

单例模式

## 模板方法模式（Template Method）

模板方法模式又叫做虚拟构造子模式或者多态性工厂模式

### 说明

定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。

### 角色

- 抽象类（Abstract Class）角色：

  负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。

  - 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法；

  - 基本方法：是实现算法各个步骤的方法。

    基本方法又可以分为三种：

    - 抽象方法（Abstract Method）：一个抽象方法由抽象类声明、由其具 体子类实现；
    - 具体方法（Concrete Method）：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承；
    - 钩子方法（Hook Method）：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。

- 具体子类（Concrete Class）角色：

  实现抽象类中所定义的抽象方法和钩子方法，它们是抽象类中定义的算法的组成步骤。

### 总结

模板方法模式提高了代码的复用性，将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中，而且实现了反向控制，通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。但是对每个不同的实现都需要定义一个子类，这会导致类的个数增加，设计变的更加抽象。又因为是反向控制结构，所以提高了代码阅读的难度。

使用场景

1) 算法的整体步骤很固定，但其中个别部分容易变动，这时可以使用模板方法模式，将容易变动的部分抽象出来，让子类实现；

2) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。

## 装饰者模式（Wrapper）

装饰者模式（包装模式）

