# DesignPattern

设计模式

## Adapter

适配器模式

### 说明

可以让一个类在两个独立的维度变化，这两个维度都可以进行扩展，适配器模式只在一个维度实现继承，所以不会因为多维度、多层次继承导致系统类的个数急剧增加，这就让构件的抽象化角色和具体化角色之间增加了更多的灵活性。

### 角色

- Abstraction：抽象类。

- RefinedAbstraction：扩充抽象类。

- Implementor：实现类接口。

- ConcreteImplementor：具体实现类 。

### 说明

将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作

### 角色

- 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。

- 需要适配的类（Adaptee）：需要适配的类或适配者类。

- 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。

## Bridge

桥接模式

## Builder

建造者模式

### 说明

**以下情况建议使用建造者模式**

- 某个对象有复杂的内部结构，通常包含多个成员属性，而且属性是可选的。

- 相同的方法，不同的执行顺序，产生不同的对象或不同的运行结果。

- 当创建一个对象需要很多步骤时，适合使用建造者模式。

## ChainOfResponsibility

责任链模式

## Factory

工厂模式

## Prototype

原型模式

### 说明

原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

## Proxy

代理模式

## Singleton

单例模式

## Wrapper

装饰者模式（包装模式）

