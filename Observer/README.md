## 观察者模式（Observer）

观察者模式又叫`发布-订阅(Publish/Subscribe)模式`、`模型-视图(Model/View)模式`、`源-监听器(Source/Listener)模式`或`从属者(Dependents)模式`。

### 一、说明

观察者模式是对象的行为模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

在观察者模式中，又分为推模型和拉模型两种方式。

- 推模型

  主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。推模型是假定主题对象知道观察者需要的数据，通过update方法中的参数传递给观察者。推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者

- 拉模型

  主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身（this）通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。拉模型不会造成观察者对象难以复用的情况，因为update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

### 二、角色

- 抽象主题(Subject)角色：又叫做抽象被观察者(Observable)角色。它把所有观察者对象（Observer）保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者（Observable）。抽象主题角色提供一个接口，可以增加和删除观察者对象。

- 具体主题(Concrete Subject)角色：具又叫做具体被观察者(Concrete Observable)角色。将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者（Observer）发出通知。

- 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。

- 具体观察者(Concrete Observer)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。

### 三、总结

虽然观察者模式的概念是：一对多的依赖关系，但不一定观察者有多个才能使用，观察者模式很好的降低了目标与观察者之间的耦合关系，使得目标与观察者建立了一套触发机制，从而让各自的变换都不会影响另一边的变换，也成为了最常见的设计模式。

使用场景：

1) 一个对象的改变会导致一个或多个对象发生改变，而并不知道具体有多少对象将会发生改变，也不知道这些对象是谁。
2) 一个抽象模型有两个维度，而且一个维度（Observer）依赖另一个维度（Subject），可将这两者封装在一个独立的对象（Concrete Subject）中，让其可以各自独立地改变和复用，并可以让一个维度的状态改变（Subject）通知另一个维度（Observer）。
3) 需要在系统中创建一个触发链，使得事件可以通知多种观察者类型。

典型应用：

1) 聊天室程序，服务器转发给所有客户端
2) 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发
3) 邮件订阅
4) Servlet中，监听器的实现
5) Android中，广播机制
6) 电商中，群发某商品打折信息
7) Redis 中的基于频道的发布订阅
