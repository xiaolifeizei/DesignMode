## 状态模式（State）

状态模式也叫作状态机模式

### 一、说明

状态模式属于行为型设计模式。运行对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。状态模式中类的行为是由状态决定的，在不同的状态下有不同的行为。

- 设计意图：让一个对象在其内部改变的时候，行为也随之改变。
- 模式核心：状态与行为绑定，不同的状态对应不同的行为。

状态机有三个组成部分：状态、事件和动作。触发某个事件可以改变对象的状态。

### 二、角色

- 抽象状态（State）角色：

  接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换。

- 具体状态（Concrete State）角色：

  每个具体状态角色必须完成两个职责：本状态的行为处理和趋向状态处理，就是本状态下要做的事和本状态如何过渡到其他状态。

- 环境（Context）角色：

  定义客户端需要的接口，并且负责具体状态的切换。

  环境角色有两个不成文的约束：

  - 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量。
  - 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。

### 三、总结

避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，将对象的状态变换放置到类的内部来实现，结构清晰，外部的调用不用知道类内部是如何实现状态和行为的变换的。行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过五个。

使用场景：

1. 行为随状态改变而改变的场景

   这是状态模式的根本出发点。

   如权限设计：人员的状态不同即使执行相同的行为结果也会不同，这种情况下可以考虑使用状态模式。

2. 替代条件、分支判断语句，并且这些分支取决于对象的状态

   程序中大量使用switch语句或者if判断语句会导致程序结构不清晰，逻辑混乱，状态模式通过扩展子类实现了条件的判断处理。

状态模式和策略模式的类图架构几乎完全一样，但两者的应用场景是不一样的。策略模式的多种算法行为择其一都能满足，**彼此之间是独立的**，用户可自行更换策略算法；而状态模式的各个状态之间存在相互关系，彼此之间一定的条件下存在自动切换的效果，并且用户无法指定状态，**只能设置初始状态**，因为状态是根据行为而改变的。
