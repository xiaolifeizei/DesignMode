## 策略模式（Strategy）

策略模式

### 一、说明

定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。可以代替多重`if-else`和`switch`语句，将对象和行为分开，将行为定义为 一个行为接口和具体行为的实现，每个if判断都可以理解为一个策略，让代码维护变得更加简单，。

### 二、角色

- 抽象策略（Strategy）角色：

  接口或抽象类，定义若干个算法标识，即若干个抽象方法

- 具体策略（Concrete Strategy）角色：

  抽象策略角色的子类，实现了抽象策略定义的抽象方法（实现相关的算法、行为）

- 环境类 /上下文（Context）角色：

  持有一个策略角色的引用并提供一个方法给客户端调用，该方法委托执行具体策略角色的方法

### 三、总结

与状态模式对比：

1) 策略模式各个策略之间并不存在**流转**关系，都是各自的算法实现各自的逻辑，由客户端选择调用的策略，调用完成后就结束了。

2) 策略模式调用哪个策略由客户端决定；状态模式中，客户端只管调用，由各个具体状态类来切换下一状态。

3) 状态模式强调状态变化、策略模式强调的是策略的选择。

使用场景

1) 一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。

2) 一个类定义了多种行为，这些行为在操作中以多个条件语句的形式出现，可将每个条件移入各自的策略类中代替这些条件语句。

3) 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。

4) 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。

5) 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。
